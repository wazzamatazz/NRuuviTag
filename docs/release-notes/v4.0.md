# NRuuviTag v4.0 Release Notes

Version 4.0 represents a major update to the NRuuviTag library collection, introducing significant improvements to the API design, expanded data format support, and new publishing capabilities. This release includes several breaking changes that improve consistency, maintainability, and align with modern .NET best practices.

---

## Breaking Changes

### 1. Package Renames

The following NuGet packages have been renamed to better reflect their purpose as publishers of Ruuvi sensor data:

- `NRuuviTag.AzureEventHubs.Agent` --> `NRuuviTag.AzureEventHubs.Publisher`
- `NRuuviTag.Mqtt.Agent` --> `NRuuviTag.Mqtt.Publisher`

**Old Behaviour (v3.0.0):**
```csharp
using NRuuviTag.Mqtt.Agent;
using NRuuviTag.AzureEventHubs.Agent;

var mqttAgent = new MqttAgent(listener, options, factory, logger);
var eventHubAgent = new AzureEventHubAgent(listener, options, logger);
```

**New Behaviour (v4.0.0):**
```csharp
using NRuuviTag.Mqtt.Publisher;
using NRuuviTag.AzureEventHubs.Publisher;

var mqttPublisher = new MqttPublisher(listener, options, factory, logger);
var eventHubPublisher = new AzureEventHubPublisher(listener, options, logger);
```

**Migration Steps:**
1. Uninstall the old packages:
   ```bash
   dotnet remove package NRuuviTag.Mqtt.Agent
   dotnet remove package NRuuviTag.AzureEventHubs.Agent
   ```

2. Install the new packages:
   ```bash
   dotnet add package NRuuviTag.Mqtt.Publisher
   dotnet add package NRuuviTag.AzureEventHubs.Publisher
   ```

3. Update all `using` statements and type references in your code from `*Agent` to `*Publisher`.

---

### 2. Target Framework Upgrade

All libraries have been upgraded from `.NET Standard 2.1` to `.NET 10`:

- [NRuuviTag.Core](../../src/NRuuviTag.Core)
- [NRuuviTag.Listener.Linux](../../src/NRuuviTag.Listener.Linux)
- [NRuuviTag.Listener.Windows](../../src/NRuuviTag.Listener.Windows)
- [NRuuviTag.AzureEventHubs.Publisher](../../src/NRuuviTag.AzureEventHubs.Publisher)
- [NRuuviTag.Mqtt.Publisher](../../src/NRuuviTag.Mqtt.Publisher)
- [NRuuviTag.OpenTelemetry](../../src/NRuuviTag.OpenTelemetry)

**Impact:**
- Applications must target .NET 10 or later to use these libraries
- Enables use of modern C# features such as `record` types, `init`-only properties, and file-scoped namespaces
- Improved performance and reduced memory allocations through .NET 10 runtime optimizations

**Migration Steps:**

Update your project file to target .NET 10:

```xml
<PropertyGroup>
  <TargetFramework>net10.0</TargetFramework>
</PropertyGroup>
```

---

### 3. Core Type Refactoring: `class` to `record`

`RuuviTagSample` and `RuuviTagSampleExtended` have been converted from mutable classes to immutable records with `init`-only properties.

**Old Behaviour (v3.0.0):**
```csharp
public class RuuviTagSample {
    public DateTimeOffset? Timestamp { get; set; }
    public string? MacAddress { get; set; }
    public double? Temperature { get; set; }
    public double? Humidity { get; set; }
    // ... other properties with set accessors
}

public class RuuviTagSampleExtended : RuuviTagSample {
    public string? DeviceId { get; set; }
    public string? DisplayName { get; set; }
}

// Usage
var sample = new RuuviTagSample {
    MacAddress = "AB:CD:EF:01:23:45",
    Temperature = 22.5
};
sample.Temperature = 23.0; // Properties can be modified after construction
```

**New Behaviour (v4.0.0):**
```csharp
public record RuuviTagSample : RuuviDataPayload {
    public DateTimeOffset? Timestamp { get; init; }
    public double? SignalStrength { get; init; }
    // Sensor data properties inherited from RuuviDataPayload
}

public record RuuviTagSampleExtended : RuuviTagSample {
    public string? DeviceId { get; init; }
    public string? DisplayName { get; init; }
}

// Usage - object initializer
var sample = new RuuviTagSample {
    MacAddress = "AB:CD:EF:01:23:45",
    Temperature = 22.5
};
// sample.Temperature = 23.0; // Compile error - properties are init-only

// Usage - with expression for non-destructive mutation
var updated = sample with { Temperature = 23.0 };
```

**Impact:**
- Properties can only be set during object construction or via `with` expressions
- Records provide value-based equality instead of reference equality
- Records support non-destructive mutation via `with` expressions
- Code that modifies sample properties after construction must be updated

**Migration Steps:**

Replace property assignments with `with` expressions:

```csharp
// Old approach
var sample = GetSample();
sample.DeviceId = "sensor-01";

// New approach
var sample = GetSample();
sample = sample with { DeviceId = "sensor-01" };
```

Or use constructor-based initialization:

```csharp
var extended = new RuuviTagSampleExtended(
    DeviceId: "sensor-01",
    DisplayName: "Living Room",
    sample
);
```

---

### 4. Introduction of `RuuviDataPayload`

A new base type `RuuviDataPayload` has been introduced to represent the raw sensor data payload. `RuuviTagSample` now inherits from this base type. `RuuviDataPayload` contains a composite of all sensor measurement properties from the Raw V2 format used by RuuviTag and the new Extended V1 format used by the new Ruuvi Air air quality sensor.

**Old Behaviour (v3.0.0):**
```csharp
public class RuuviTagSample {
    public DateTimeOffset? Timestamp { get; set; }
    public string? MacAddress { get; set; }
    public byte? DataFormat { get; set; }
    public double? Temperature { get; set; }
    public double? Humidity { get; set; }
    public double? Pressure { get; set; }
    // ... all sensor measurements in same class
}
```

**New Behaviour (v4.0.0):**
```csharp
// Base payload containing all sensor measurements
public record RuuviDataPayload {
    public byte? DataFormat { get; init; }
    public bool? Calibrated { get; init; }
    public string? MacAddress { get; init; }
    public double? Temperature { get; init; }
    public double? Humidity { get; init; }
    public double? Pressure { get; init; }
    public double? AccelerationX { get; init; }
    public double? AccelerationY { get; init; }
    public double? AccelerationZ { get; init; }
    public double? BatteryVoltage { get; init; }
    public double? TxPower { get; init; }
    public int? MovementCounter { get; init; }
    public int? MeasurementSequence { get; init; }
}

// Sample adds metadata about the observation
public record RuuviTagSample : RuuviDataPayload {
    public DateTimeOffset? Timestamp { get; init; }
    public double? SignalStrength { get; init; }
}
```

**Impact:**
- Better separation of concerns: raw payload data vs. sample metadata
- All sensor measurement properties remain accessible on `RuuviTagSample` via inheritance
- Allows working directly with `RuuviDataPayload` when sample metadata is not needed

**Migration Steps:**

No code changes required for basic usage - all properties remain accessible on `RuuviTagSample`. If you need to work with just the payload data without metadata:

```csharp
RuuviDataPayload payload = sample; // Upcast to work with just the sensor data
```

---

### 5. `RuuviTagPublisher` API Changes

The abstract `RuuviTagPublisher` base class has been significantly refactored to improve flexibility and align with publisher naming conventions.

#### Constructor Signature Changes

**Old Behaviour (v3.0.0):**
```csharp
protected RuuviTagPublisher(
    IRuuviTagListener listener,
    int publishInterval,
    Func<string, bool>? filter = null,
    ILogger<RuuviTagPublisher>? logger = null
)
```

**New Behaviour (v4.0.0):**
```csharp
protected RuuviTagPublisher(
    IRuuviTagListener listener,
    RuuviTagPublisherOptions options,
    Func<string, bool>? deviceFilter = null,
    ILogger<RuuviTagPublisher>? logger = null
)
```

**Impact:**
- The `publishInterval` parameter has been replaced with a `RuuviTagPublisherOptions` object
- The `filter` parameter has been renamed to `deviceFilter` for clarity
- Configuration is now centralized in the options object

#### `RunAsync` Method Signature Changes

**Old Behaviour (v3.0.0):**
```csharp
protected abstract Task RunAsync(
    IAsyncEnumerable<RuuviTagSample> samples,
    CancellationToken cancellationToken
);

// Example implementation
protected override async Task RunAsync(
    IAsyncEnumerable<RuuviTagSample> samples,
    CancellationToken cancellationToken
) {
    await foreach (var sample in samples.WithCancellation(cancellationToken)) {
        // Process sample
    }
}
```

**New Behaviour (v4.0.0):**
```csharp
protected abstract Task RunAsync(
    ChannelReader<RuuviTagSample> samples,
    CancellationToken cancellationToken
);

// Example implementation
protected override async Task RunAsync(
    ChannelReader<RuuviTagSample> samples,
    CancellationToken cancellationToken
) {
    while (await samples.WaitToReadAsync(cancellationToken)) {
        while (samples.TryRead(out var sample)) {
            // Process sample
        }
    }
}
```

**Impact:**
- Provides more control over sample consumption patterns
- Enables efficient batch processing
- Allows checking for available samples without blocking
- Built-in publishers (MQTT, Azure Event Hubs, HTTP) have been updated to use the new signature

**Migration Steps:**

If you have custom publisher implementations, update the `RunAsync` method:

```csharp
// Old implementation
protected override async Task RunAsync(
    IAsyncEnumerable<RuuviTagSample> samples,
    CancellationToken cancellationToken
) {
    await foreach (var sample in samples.WithCancellation(cancellationToken)) {
        await ProcessSampleAsync(sample, cancellationToken);
    }
}

// New implementation
protected override async Task RunAsync(
    ChannelReader<RuuviTagSample> samples,
    CancellationToken cancellationToken
) {
    while (await samples.WaitToReadAsync(cancellationToken)) {
        while (samples.TryRead(out var sample)) {
            await ProcessSampleAsync(sample, cancellationToken);
        }
    }
}
```

For batch processing scenarios:

```csharp
protected override async Task RunAsync(
    ChannelReader<RuuviTagSample> samples,
    CancellationToken cancellationToken
) {
    var batch = new List<RuuviTagSample>();

    while (await samples.WaitToReadAsync(cancellationToken)) {
        while (samples.TryRead(out var sample)) {
            batch.Add(sample);
            if (batch.Count >= MaxBatchSize) {
                await ProcessBatchAsync(batch, cancellationToken);
                batch.Clear();
            }
        }

        if (batch.Count > 0) {
            await ProcessBatchAsync(batch, cancellationToken);
            batch.Clear();
        }
    }
}
```

---

### 6. JSON Property Name Attributes

All properties on `RuuviDataPayload`, `RuuviTagSample`, and `RuuviTagSampleExtended` now have explicit `[JsonPropertyName]` attributes to ensure consistent JSON serialization regardless of serializer settings.

**Old Behaviour (v3.0.0):**
```csharp
public class RuuviTagSample {
    public double? Temperature { get; set; }
    public double? Humidity { get; set; }
}

// JSON output depended on serializer settings:
// With default settings: {"Temperature":22.5,"Humidity":45.0}
// With camelCase: {"temperature":22.5,"humidity":45.0}
```

**New Behaviour (v4.0.0):**
```csharp
public record RuuviTagSample : RuuviDataPayload {
    [JsonPropertyName("temperature")]
    public double? Temperature { get; init; }

    [JsonPropertyName("humidity")]
    public double? Humidity { get; init; }
}

// JSON output is always consistent (camelCase):
// {"temperature":22.5,"humidity":45.0}
```

**Impact:**
- JSON property names are now always in camelCase, regardless of serializer configuration
- Applications that parse JSON output from NRuuviTag must expect camelCase property names
- Ensures consistent API contracts across different serializer configurations

**Migration Steps:**

If your code parses JSON output from NRuuviTag, update property name expectations:

```csharp
// Old code expecting PascalCase
var json = JObject.Parse(jsonString);
var temp = json["Temperature"].Value<double>();

// Updated for camelCase
var json = JObject.Parse(jsonString);
var temp = json["temperature"].Value<double>();
```

Or use strongly-typed deserialization which will work automatically:

```csharp
var sample = JsonSerializer.Deserialize<RuuviTagSample>(jsonString);
```

---

## New Features

### HTTP Publisher

A new `NRuuviTag.Http.Publisher` package enables publishing Ruuvi sensor data to HTTP endpoints.

**Example Usage:**
```csharp
using NRuuviTag.Http.Publisher;

var options = new HttpPublisherOptions() {
    Endpoint = "https://my-receiver.local/api/samples",
    Method = HttpMethod.Post,
    MaxBatchSize = 100,
    PublishInterval = TimeSpan.FromSeconds(30),
    Headers = new Dictionary<string, string>() {
        ["X-API-Key"] = "MY_API_KEY",
        ["Content-Type"] = "application/json"
    }
};

await using var publisher = new HttpPublisher(
    listener,
    options,
    httpClientFactory,
    logger
);

await publisher.RunAsync(cancellationToken);
```

**Features:**
- Configurable HTTP method (POST or PUT)
- Custom request headers
- Batch publishing with configurable size
- Integration with `IHttpClientFactory` for connection pooling and resiliency integration

---

### Extended V1 Data Format Support

NRuuviTag now supports the Extended V1 data format used by the new Ruuvi Air device, in addition to the existing Raw V2 format.

**Supported Formats:**
- **Data Format 5 (Raw V2)**: Original RuuviTag data format
- **Data Format 11 (Extended V1)**: New format used by Ruuvi Air with calibration flag and extended capabilities

**New Properties:**
- `Calibrated` (`bool?`): Indicates whether sensor values have been factory-calibrated (Extended V1 only)
- `DataFormat` (`byte?`): Identifies the data format version (`0x05` for Raw V2, `0xE1` for Extended V1)

**Example:**
```csharp
await foreach (var sample in listener.ListenAsync(cancellationToken)) {
    Console.WriteLine($"Format: {sample.DataFormat}");

    if (sample is { DataFormat: 0xE1, Calibrated: true }) {
        Console.WriteLine("Extended V1 format with calibrated sensors");
    }

    Console.WriteLine($"Temperature: {sample.Temperature} degC");
    Console.WriteLine($"Humidity: {sample.Humidity} %");
    Console.WriteLine($"Pressure: {sample.Pressure} hPa");
}
```

---

### Listener Start Signal

The `RuuviTagListener` base class now provides a `WaitForListenStartedAsync` method that allows callers to wait until the listener has started actively listening for advertisements.

**Example Usage:**
```csharp
var listener = new WindowsSdkListener();

// Start listening in the background
var listenTask = Task.Run(async () => {
    await foreach (var sample in listener.ListenAsync(cancellationToken)) {
        ProcessSample(sample);
    }
});

// Wait for the listener to actually start before proceeding
await listener.WaitForListenStartedAsync(cancellationToken);
Console.WriteLine("Listener is now active and scanning for devices");

// Continue with application logic knowing the listener is ready
```

**Use Cases:**
- Ensure listener is ready before showing UI indicating scanning state
- Coordinate startup of multiple components
- Testing scenarios where you need to verify listener initialization

---

### Flush Method for Publishers

Publishers now expose a `Flush()` method to force immediate publishing of any pending samples when using scheduled publishing intervals.

**Example Usage:**
```csharp
var options = new MqttPublisherOptions() {
    // ... other options
};

var publisherOptions = new RuuviTagPublisherOptions() {
    PublishInterval = TimeSpan.FromMinutes(5) // Batch samples for 5 minutes
};

await using var publisher = new MqttPublisher(listener, options, factory, logger);

// Start publishing in the background
var publishTask = publisher.RunAsync(cancellationToken);

// Later, force an immediate publish
publisher.Flush();
Console.WriteLine("Pending samples have been published immediately");
```

**Notes:**
- Has no effect if `PublishInterval` is zero (samples are published immediately)
- Useful for ensuring data is sent before application shutdown
- Can be called multiple times as needed

---

## Other Improvements

### File-Scoped Namespaces

All source files now use file-scoped namespaces for improved readability and reduced indentation:

```csharp
// Old style
namespace NRuuviTag {
    public class MyClass {
        // ...
    }
}

// New style
namespace NRuuviTag;

public class MyClass {
    // ...
}
```

### Expanded Documentation

All packages now include README.md files with usage examples and API documentation:
- [NRuuviTag.Core](../../src/NRuuviTag.Core/README.md)
- [NRuuviTag.Listener.Windows](../../src/NRuuviTag.Listener.Windows/README.md)
- [NRuuviTag.Listener.Linux](../../src/NRuuviTag.Listener.Linux/README.md)
- [NRuuviTag.Mqtt.Publisher](../../src/NRuuviTag.Mqtt.Publisher/README.md)
- [NRuuviTag.AzureEventHubs.Publisher](../../src/NRuuviTag.AzureEventHubs.Publisher/README.md)
- [NRuuviTag.Http.Publisher](../../src/NRuuviTag.Http.Publisher/README.md)
- [NRuuviTag.OpenTelemetry](../../src/NRuuviTag.OpenTelemetry/README.md)

### Improved Test Coverage

- Comprehensive test cases for payload parsing (Raw V2 and Extended V1 formats)
- Parameterized tests for better maintainability
- New benchmarks for payload parsing performance

### Enhanced CLI

The `nruuvitag` CLI tool has been updated with a new `publish http` command for publishing samples to HTTP endpoints:

```bash
nruuvitag publish http --endpoint "https://my-api.local/samples" --header "X-API-Key: MY_KEY"
```

---

## Summary

Version 4.0 represents a significant modernization of the NRuuviTag library collection. While there are breaking changes, they align the codebase with modern .NET best practices and provide a more consistent, flexible API. The addition of HTTP publishing and Extended V1 format support expands the capabilities of the library to support more scenarios and newer Ruuvi devices.

For most applications, the migration path is straightforward:
1. Update NuGet package references
2. Update target framework to .NET 10
3. Replace `*Agent` type names with `*Publisher`
4. Update custom publishers to use the new `ChannelReader`-based `RunAsync` signature
5. Replace property mutations with `with` expressions

For assistance with migration or questions about v4.0, please [open an issue](https://github.com/intelligentplant/NRuuviTag/issues) on GitHub.